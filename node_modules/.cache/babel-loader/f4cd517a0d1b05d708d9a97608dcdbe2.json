{"ast":null,"code":"/**\n * @copyright 2015, Andrey Popp <8mayday@gmail.com>\n *\n * The decorator may be used on classes or methods\n * ```\n * @autobind\n * class FullBound {}\n *\n * class PartBound {\n *   @autobind\n *   method () {}\n * }\n * ```\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = autobind;\n\nfunction autobind() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 1) {\n    return boundClass.apply(undefined, args);\n  } else {\n    return boundMethod.apply(undefined, args);\n  }\n}\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\n\n\nfunction boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys = undefined; // Use Reflect if exists\n\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype); // use symbols if support is provided\n\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key); // Only methods need binding\n\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\n\n\nfunction boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);\n  } // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n\n\n  var definingProperty = false;\n  return {\n    configurable: true,\n    get: function get() {\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        value: boundFn,\n        configurable: true,\n        writable: true\n      });\n      definingProperty = false;\n      return boundFn;\n    }\n  };\n}\n\nmodule.exports = exports['default'];","map":{"version":3,"sources":["E:/Project/Coding/New folder/feedback-system-master/node_modules/autobind-decorator/lib/index.js"],"names":["Object","defineProperty","exports","value","autobind","_len","arguments","length","args","Array","_key","boundClass","apply","undefined","boundMethod","target","keys","Reflect","ownKeys","prototype","getOwnPropertyNames","getOwnPropertySymbols","concat","forEach","key","descriptor","getOwnPropertyDescriptor","fn","Error","definingProperty","configurable","get","hasOwnProperty","boundFn","bind","writable","module"],"mappings":"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","sourcesContent":["/**\n * @copyright 2015, Andrey Popp <8mayday@gmail.com>\n *\n * The decorator may be used on classes or methods\n * ```\n * @autobind\n * class FullBound {}\n *\n * class PartBound {\n *   @autobind\n *   method () {}\n * }\n * ```\n */\n'use strict';\n\nObject.defineProperty(exports, '__esModule', {\n  value: true\n});\nexports['default'] = autobind;\n\nfunction autobind() {\n  for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {\n    args[_key] = arguments[_key];\n  }\n\n  if (args.length === 1) {\n    return boundClass.apply(undefined, args);\n  } else {\n    return boundMethod.apply(undefined, args);\n  }\n}\n\n/**\n * Use boundMethod to bind all methods on the target.prototype\n */\nfunction boundClass(target) {\n  // (Using reflect to get all keys including symbols)\n  var keys = undefined;\n  // Use Reflect if exists\n  if (typeof Reflect !== 'undefined' && typeof Reflect.ownKeys === 'function') {\n    keys = Reflect.ownKeys(target.prototype);\n  } else {\n    keys = Object.getOwnPropertyNames(target.prototype);\n    // use symbols if support is provided\n    if (typeof Object.getOwnPropertySymbols === 'function') {\n      keys = keys.concat(Object.getOwnPropertySymbols(target.prototype));\n    }\n  }\n\n  keys.forEach(function (key) {\n    // Ignore special case target method\n    if (key === 'constructor') {\n      return;\n    }\n\n    var descriptor = Object.getOwnPropertyDescriptor(target.prototype, key);\n\n    // Only methods need binding\n    if (typeof descriptor.value === 'function') {\n      Object.defineProperty(target.prototype, key, boundMethod(target, key, descriptor));\n    }\n  });\n  return target;\n}\n\n/**\n * Return a descriptor removing the value and returning a getter\n * The getter will return a .bind version of the function\n * and memoize the result against a symbol on the instance\n */\nfunction boundMethod(target, key, descriptor) {\n  var fn = descriptor.value;\n\n  if (typeof fn !== 'function') {\n    throw new Error('@autobind decorator can only be applied to methods not: ' + typeof fn);\n  }\n\n  // In IE11 calling Object.defineProperty has a side-effect of evaluating the\n  // getter for the property which is being replaced. This causes infinite\n  // recursion and an \"Out of stack space\" error.\n  var definingProperty = false;\n\n  return {\n    configurable: true,\n    get: function get() {\n      if (definingProperty || this === target.prototype || this.hasOwnProperty(key)) {\n        return fn;\n      }\n\n      var boundFn = fn.bind(this);\n      definingProperty = true;\n      Object.defineProperty(this, key, {\n        value: boundFn,\n        configurable: true,\n        writable: true\n      });\n      definingProperty = false;\n      return boundFn;\n    }\n  };\n}\nmodule.exports = exports['default'];\n"]},"metadata":{},"sourceType":"script"}